from flask import Flask, jsonify, request
import requests
import json
from datetime import datetime
import os

app = Flask(__name__)

# Archivo para guardar historial
HISTORIAL_FILE = 'historial_apuestas.json'

@app.route('/')
def home():
    """P√°gina principal del robot"""
    return jsonify({
        'robot': 'ü§ñ Sistema de Apuestas FUNCIONANDO',
        'version': '2.0',
        'estado': 'ACTIVO',
        'ultima_actualizacion': datetime.now().isoformat(),
        'rutas_disponibles': {
            '/health': 'Verificar estado del sistema',
            '/webhook': 'Recibir datos desde N8N',
            '/historial': 'Ver √∫ltimas apuestas analizadas', 
            '/estadisticas': 'Ver estad√≠sticas del robot',
            '/analizar': 'Ejecutar an√°lisis manual',
            '/reset': 'Limpiar historial',
            '/test-telegram': 'Probar env√≠o a Telegram'
        }
    })

@app.route('/health')
def health():
    """Verificar que el sistema funciona"""
    return jsonify({
        'status': '‚úÖ FUNCIONANDO PERFECTAMENTE',
        'servidor': 'Render.com',
        'hora_servidor': datetime.now().isoformat(),
        'memoria_disponible': 'OK',
        'apis_conectadas': 'OK',
        'telegram_token': '‚úÖ Configurado' if os.getenv('TELEGRAM_TOKEN') else '‚ùå NO configurado',
        'telegram_chat': '‚úÖ Configurado' if os.getenv('TELEGRAM_CHAT') else '‚ùå NO configurado'
    })

@app.route('/webhook', methods=['POST'])
def webhook():
    """Recibe y guarda datos de an√°lisis desde N8N"""
    try:
        datos = request.get_json()
        print(f"üì• Datos recibidos: {datos}")  # Debug log
        
        # Crear registro completo
        registro = {
            'id': f"apuesta_{int(datetime.now().timestamp())}",
            'timestamp': datetime.now().isoformat(),
            'fecha_analisis': datetime.now().strftime('%d/%m/%Y %H:%M'),
            'partido': datos.get('partido', 'Sin datos'),
            'liga': datos.get('liga', 'Sin especificar'),
            'cuotas': datos.get('cuotas', {}),
            'probabilidades': datos.get('probabilidades', {}),
            'recomendacion': datos.get('recomendacion', 'Sin recomendaci√≥n'),
            'confianza': datos.get('confianza', '0%'),
            'apostar': datos.get('apostar', '0%'),
            'valor': datos.get('valor', 'NO'),
            'casa': datos.get('casa', 'N/A'),
            'origen': 'N8N_Robot'
        }
        
        print(f"üìã Registro creado: {registro}")  # Debug log
        
        # Cargar historial existente
        try:
            with open(HISTORIAL_FILE, 'r', encoding='utf-8') as f:
                historial = json.load(f)
        except FileNotFoundError:
            historial = []
        except json.JSONDecodeError:
            historial = []
        
        # Agregar nuevo registro
        historial.append(registro)
        
        # Mantener solo los √∫ltimos 200 registros
        historial = historial[-200:]
        
        # Guardar historial actualizado
        with open(HISTORIAL_FILE, 'w', encoding='utf-8') as f:
            json.dump(historial, f, indent=2, ensure_ascii=False)
        
        # SIEMPRE enviar a Telegram (para debug)
        telegram_resultado = notificar_telegram_siempre(registro)
        
        return jsonify({
            'status': '‚úÖ GUARDADO EXITOSAMENTE',
            'registro_id': registro['id'],
            'partido': registro['partido'],
            'total_historial': len(historial),
            'telegram_enviado': telegram_resultado,
            'mensaje': 'An√°lisis guardado en Render'
        })
        
    except Exception as e:
        print(f"‚ùå Error en webhook: {e}")
        return jsonify({
            'status': '‚ùå ERROR',
            'mensaje': f'Error procesando datos: {str(e)}',
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route('/historial')
def historial():
    """Ver historial de an√°lisis"""
    try:
        with open(HISTORIAL_FILE, 'r', encoding='utf-8') as f:
            historial = json.load(f)
        
        # Estad√≠sticas r√°pidas
        total = len(historial)
        con_valor = sum(1 for h in historial if h.get('valor') == 'S√ç')
        
        return jsonify({
            'resumen': {
                'total_analisis': total,
                'con_valor': con_valor,
                'sin_valor': total - con_valor,
                'porcentaje_valor': f"{(con_valor/total*100 if total > 0 else 0):.1f}%"
            },
            'ultimos_10': historial[-10:],  # √öltimos 10 an√°lisis
            'timestamp': datetime.now().isoformat()
        })
        
    except FileNotFoundError:
        return jsonify({
            'resumen': {
                'total_analisis': 0,
                'con_valor': 0,
                'sin_valor': 0,
                'porcentaje_valor': '0%'
            },
            'ultimos_10': [],
            'mensaje': 'Sin historial a√∫n'
        })

@app.route('/estadisticas')
def estadisticas():
    """Estad√≠sticas detalladas del robot"""
    try:
        with open(HISTORIAL_FILE, 'r', encoding='utf-8') as f:
            historial = json.load(f)
        
        if not historial:
            return jsonify({'mensaje': 'Sin datos para estad√≠sticas'})
        
        # Calcular estad√≠sticas
        total = len(historial)
        con_valor = [h for h in historial if h.get('valor') == 'S√ç']
        
        # Por liga
        ligas = {}
        for h in historial:
            liga = h.get('liga', 'Sin especificar')
            ligas[liga] = ligas.get(liga, 0) + 1
        
        # √öltimas recomendaciones
        ultimas_recomendaciones = [h.get('recomendacion', 'N/A') for h in historial[-5:]]
        
        return jsonify({
            'estadisticas_generales': {
                'total_partidos_analizados': total,
                'partidos_con_valor': len(con_valor),
                'tasa_valor': f"{(len(con_valor)/total*100 if total > 0 else 0):.1f}%",
                'primer_analisis': historial[0]['fecha_analisis'] if historial else None,
                'ultimo_analisis': historial[-1]['fecha_analisis'] if historial else None
            },
            'por_liga': ligas,
            'ultimas_recomendaciones': ultimas_recomendaciones,
            'mejor_partido': con_valor[0] if con_valor else None,
            'robot_activo_desde': datetime.now().strftime('%d/%m/%Y')
        })
        
    except Exception as e:
        return jsonify({
            'error': f'Error generando estad√≠sticas: {str(e)}',
            'timestamp': datetime.now().isoformat()
        })

@app.route('/analizar')
def analizar_manual():
    """Trigger manual para pruebas"""
    mensaje = f"ü§ñ An√°lisis manual ejecutado - {datetime.now().strftime('%H:%M')}"
    
    # Si tienes Telegram configurado, enviar notificaci√≥n
    if os.getenv('TELEGRAM_TOKEN') and os.getenv('TELEGRAM_CHAT'):
        try:
            url = f"https://api.telegram.org/bot{os.getenv('TELEGRAM_TOKEN')}/sendMessage"
            data = {
                'chat_id': os.getenv('TELEGRAM_CHAT'),
                'text': f"üîÑ {mensaje}\n\n‚úÖ Robot funcionando desde Render\nüîó Sistema conectado correctamente"
            }
            response = requests.post(url, json=data, timeout=10)
            telegram_status = "‚úÖ Enviado" if response.status_code == 200 else f"‚ö†Ô∏è Error: {response.status_code}"
        except Exception as e:
            telegram_status = f"‚ùå Error: {str(e)}"
    else:
        telegram_status = "‚öôÔ∏è Telegram no configurado"
    
    return jsonify({
        'mensaje': mensaje,
        'telegram': telegram_status,
        'render_status': '‚úÖ Funcionando',
        'siguiente_paso': 'Ejecutar flujo N8N para obtener datos reales'
    })

@app.route('/reset')
def reset_historial():
    """Limpiar historial (solo para testing)"""
    try:
        with open(HISTORIAL_FILE, 'w', encoding='utf-8') as f:
            json.dump([], f)
        
        return jsonify({
            'status': '‚úÖ HISTORIAL LIMPIO',
            'mensaje': 'Todos los registros han sido eliminados',
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({
            'status': '‚ùå ERROR',
            'mensaje': f'Error limpiando historial: {str(e)}'
        }), 500

@app.route('/test-telegram')
def test_telegram():
    """Probar env√≠o directo a Telegram"""
    try:
        token = os.getenv('TELEGRAM_TOKEN')
        chat = os.getenv('TELEGRAM_CHAT')
        
        if not token:
            return jsonify({'error': '‚ùå TELEGRAM_TOKEN no configurado'})
        
        if not chat:
            return jsonify({'error': '‚ùå TELEGRAM_CHAT no configurado'})
        
        # Crear mensaje de prueba
        registro_prueba = {
            'partido': 'PRUEBA SISTEMA vs FUNCIONANDO',
            'liga': 'Test League',
            'fecha_analisis': datetime.now().strftime('%d/%m/%Y %H:%M'),
            'recomendacion': '‚úÖ Sistema operativo',
            'confianza': '100%',
            'apostar': '0%',
            'valor': 'FUNCIONANDO'
        }
        
        resultado = notificar_telegram_siempre(registro_prueba)
        
        return jsonify({
            'status': 'üß™ PRUEBA TELEGRAM',
            'resultado': resultado,
            'token_configurado': '‚úÖ S√≠',
            'chat_configurado': '‚úÖ S√≠'
        })
        
    except Exception as e:
        return jsonify({
            'error': f'‚ùå Error en prueba: {str(e)}',
            'timestamp': datetime.now().isoformat()
        })

def notificar_telegram_siempre(registro):
    """Enviar SIEMPRE a Telegram (para debug y pruebas)"""
    try:
        token = os.getenv('TELEGRAM_TOKEN')
        chat = os.getenv('TELEGRAM_CHAT')
        
        if not token or not chat:
            return "‚ùå Token o Chat no configurados"
        
        # Crear mensaje formateado
        mensaje = f"""üéØ AN√ÅLISIS COMPLETADO üéØ

üèÄ {registro.get('partido', 'Sin datos')}
üèÜ Liga: {registro.get('liga', 'N/A')}
üìÖ An√°lisis: {registro.get('fecha_analisis', 'N/A')}

üí° Recomendaci√≥n: {registro.get('recomendacion', 'N/A')}
üìä Confianza: {registro.get('confianza', '0%')}
üí∞ Apostar: {registro.get('apostar', '0%')} del bankroll
‚úÖ Valor: {registro.get('valor', 'NO')}

ü§ñ Robot funcionando desde Render
‚è∞ {datetime.now().strftime('%H:%M:%S')}"""

        # Enviar mensaje
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        data = {
            'chat_id': chat,
            'text': mensaje,
            'parse_mode': 'HTML'
        }
        
        response = requests.post(url, json=data, timeout=10)
        
        if response.status_code == 200:
            return "‚úÖ Mensaje enviado correctamente"
        else:
            return f"‚ö†Ô∏è Error HTTP: {response.status_code} - {response.text}"
            
    except Exception as e:
        return f"‚ùå Error enviando: {str(e)}"

def notificar_telegram_valor(registro):
    """Enviar notificaci√≥n especial cuando hay valor alto"""
    try:
        token = os.getenv('TELEGRAM_TOKEN')
        chat = os.getenv('TELEGRAM_CHAT') 
        
        if not token or not chat:
            return "‚ùå Telegram no configurado"
            
        mensaje = f"""üö® VALOR ALTO DETECTADO üö®

üé∞ {registro.get('partido', 'Sin datos')}
üèÜ {registro.get('liga', 'N/A')}
üìÖ {registro.get('fecha_analisis', 'N/A')}

üí∞ CUOTAS:
{registro.get('cuotas', {})}

üìä PROBABILIDADES:
{registro.get('probabilidades', {})}

üéØ RECOMENDACI√ìN: {registro.get('recomendacion', 'N/A')}
üî• CONFIANZA: {registro.get('confianza', '0%')}
üíé APOSTAR: {registro.get('apostar', '0%')} del bankroll

‚ö†Ô∏è ¬°Revisar inmediatamente!
üè™ Casa: {registro.get('casa', 'N/A')}"""

        url = f"https://api.telegram.org/bot{token}/sendMessage"
        data = {
            'chat_id': chat,
            'text': mensaje
        }
        
        response = requests.post(url, json=data, timeout=10)
        return "‚úÖ Alerta de valor enviada" if response.status_code == 200 else f"Error: {response.status_code}"
        
    except Exception as e:
        return f"‚ùå Error en notificaci√≥n: {str(e)}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)), debug=True)
